// Generated by CoffeeScript 1.4.0
(function() {
  var BUF_LENGTH, copy, dir, fs, getFileName, marked, mkdir, moment, path, read, readJSON, trashDir, tree, write, _buff;

  fs = require('fs');

  path = require('path');

  moment = require('moment');

  marked = require('marked');

  marked.setOptions({
    gfm: true,
    pedantic: false,
    sanitize: false
  });

  mkdir = exports.mkdir = function(dest) {
    var parent;
    dest = path.resolve(dest);
    parent = path.dirname(dest);
    if (fs.existsSync(parent)) {
      return fs.mkdirSync(dest);
    } else {
      mkdir(parent);
      return fs.mkdirSync(dest);
    }
  };

  dir = exports.dir = function(src, notRecursive, onlyDir) {
    var filePaths,
      _this = this;
    if (!fs.existsSync(src)) {
      return [];
    }
    if (!fs.statSync(src).isDirectory()) {
      return [src];
    }
    filePaths = [];
    fs.readdirSync(src).forEach(function(filename, i) {
      filename = path.resolve(src, filename);
      if (fs.statSync(filename).isDirectory()) {
        if (!notRecursive) {
          return filePaths = filePaths.concat(dir(filename, notRecursive, onlyDir));
        } else {
          return filePaths.push(filename);
        }
      } else {
        if (!onlyDir) {
          return filePaths.push(filename);
        }
      }
    });
    return filePaths;
  };

  tree = exports.tree = function(src, filter) {
    var children, node,
      _this = this;
    if (!fs.existsSync(src)) {
      node = {
        name: src,
        notExists: true
      };
      return node;
    }
    node = {
      name: src,
      isDir: fs.statSync(src).isDirectory()
    };
    if (!node.isDir) {
      return node;
    }
    children = [];
    fs.readdirSync(src).forEach(function(filename, i) {
      filename = path.resolve(src, filename);
      if (filter(filename) === false) {
        return;
      }
      if (fs.statSync(filename).isDirectory()) {
        return children.push(tree(filename, filter));
      } else {
        return children.push({
          name: filename
        });
      }
    });
    node.children = children;
    return node;
  };

  read = exports.read = function(src) {
    if (fs.existsSync(src)) {
      return fs.readFileSync(src, 'utf8');
    } else {
      return '';
    }
  };

  write = exports.write = function(src, content) {
    var parent;
    parent = path.dirname(src);
    if (!fs.existsSync(parent)) {
      mkdir(parent);
    }
    return fs.writeFileSync(src, content, 'utf8');
  };

  exports.writeIfNotExist = function(src, content) {
    if (!fs.existsSync(src)) {
      write(src, content);
      return true;
    } else {
      return false;
    }
  };

  /*
  	src: '/home/user/a'
  	dest: '/home/user/b'
  	force: true
  */


  BUF_LENGTH = 64 * 1024;

  _buff = new Buffer(BUF_LENGTH);

  copy = exports.copy = function(src, dest, force) {
    var bytesRead, destExist, fdr, fdw, pos,
      _this = this;
    destExist = fs.existsSync(dest);
    if (!force && destExist) {
      return false;
    }
    if (fs.statSync(src).isDirectory()) {
      if (!destExist) {
        mkdir(dest);
      }
      fs.readdirSync(src).forEach(function(filename, i) {
        return copy(path.resolve(src, filename), path.resolve(dest, filename), force);
      });
    } else {
      /*
      		if force and destExist
      			console.log(dest)
      			fs.unlinkSync(dest) # remove dest file
      		fs.createReadStream(src).pipe(fs.createWriteStream(dest))
      */

      fdr = fs.openSync(src, 'r');
      fdw = fs.openSync(dest, 'w');
      bytesRead = 1;
      pos = 0;
      while (bytesRead > 0) {
        bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
        fs.writeSync(fdw, _buff, 0, bytesRead);
        pos += bytesRead;
      }
      fs.closeSync(fdr);
      fs.closeSync(fdw);
    }
    return true;
  };

  readJSON = exports.readJSON = function(src) {
    var content;
    content = read(src);
    if (content) {
      return JSON.parse(content);
    } else {
      return '';
    }
  };

  getFileName = exports.getFileName = function(filePath) {
    return path.basename(filePath);
  };

  exports.pathToTitle = function(filePath) {
    /*
    	fileName = getFileName(filePath).slice(0, -3)
    	fileName = fileName
    		.replace(/([^\\])\-/g, '$1 ')
    		.replace(/\\-/g, '-')
    	fileName.slice(0, 1).toUpperCase() + fileName.slice(1)
    */

    var content;
    content = read(filePath);
    return content.slice(0, content.indexOf('\n'));
  };

  exports.titleToPath = function(title) {
    var escapedWords, filename, words;
    if (typeof title === 'object') {
      words = title;
    } else {
      words = [title];
    }
    escapedWords = [];
    words.forEach(function(word, i) {
      return escapedWords[i] = word.replace(/\-/g, '\\$1');
    });
    filename = escapedWords.join('-').toLowerCase();
    if (filename.slice(-3) !== '.md') {
      return filename = filename + '.md';
    }
  };

  exports.pathToUrl = function(filePath, root) {
    return '/' + path.relative(root, filePath);
  };

  exports.getCTime = function(filePath, format) {
    var stat;
    stat = fs.statSync(filePath);
    format = format || 'YYYY-MM-DD hh:mm:ss';
    return moment(stat.ctime).format(format);
  };

  exports.getMTime = function(filePath, format) {
    var stat;
    stat = fs.statSync(filePath);
    format = format || 'YYYY-MM-DD hh:mm:ss';
    return moment(stat.mtime).format(format);
  };

  exports.mdToHtml = function(filePath) {
    if (filePath.slice(-3) === '.md') {
      filePath = filePath.slice(0, -3) + '.html';
    }
    return filePath;
  };

  exports.isMd = function(filePath) {
    return filePath.slice(-3) === '.md';
  };

  exports.isHide = function(filePath) {
    return getFileName(filePath)[0] === '.';
  };

  exports.readMdToHtml = function(filePath) {
    var file;
    return file = marked(read(filePath));
  };

  exports.sortByCreateTime = function(paths) {
    var _this = this;
    return paths.sort(function(a, b) {
      return _this.getCTime(a) < _this.getCTime(b);
    });
  };

  exports.exists = function(path) {
    var p, result, _fn, _i, _len;
    if (typeof path === !'string') {
      result = true;
      _fn = function(p) {
        if (!fs.existsSync(p)) {
          return result = false;
        }
      };
      for (_i = 0, _len = path.length; _i < _len; _i++) {
        p = path[_i];
        _fn(p);
      }
      return result;
    } else {
      return fs.existsSync(path);
    }
  };

  exports.isDir = function(path) {
    return fs.statSync(path).isDirectory();
  };

  exports.getFileInfo = function(filePath) {
    var arr, dirname, info;
    if (!this.isMd(filePath)) {
      return null;
    }
    dirname = path.dirname(filePath);
    arr = dirname.split(path.sep);
    info = {
      title: this.pathToTitle(filePath),
      basename: this.getFileName(filePath),
      path: filePath,
      dirname: dirname,
      year: arr[arr.length - 1],
      type: arr[arr.length - 2].slice(0, -1)
    };
    return info;
  };

  trashDir = './trash';

  exports.trash = function(filePath) {
    var newPath;
    if (!fs.existsSync(trashDir)) {
      mkdir(trashDir);
    }
    return newPath = path.resolve(trashDir, path.relative('./', filePath));
  };

}).call(this);
