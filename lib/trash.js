// Generated by CoffeeScript 1.4.0
(function() {
  var MyUtil, TrashList, charm, clc, file, moment, parseArg, usage, util;

  util = require('util');

  moment = require('moment');

  clc = require('cli-color');

  charm = require('charm')();

  file = require('./file');

  usage = require('./usage');

  parseArg = require('./arg').parse;

  MyUtil = require('./MyUtil');

  TrashList = (function() {

    function TrashList() {
      this.dirname = './trash';
      this.num = 0;
      this.listTip = "====================================";
      this.shortcutTip = "====================================\nShortcut: \n    " + (clc.yellow('"q"')) + "  ==>  quit.\n    " + (clc.yellow('"j"')) + "  ==>  selection up.\n    " + (clc.yellow('"k"')) + "  ==>  selection down.\n    " + (clc.yellow('"r"')) + "  ==>  recovery delete file.";
      this._createRoot();
      charm.pipe(process.stdout);
      charm.reset();
      this._rend();
      this._bindEvent();
    }

    TrashList.prototype._createRoot = function() {
      this.rootNode = file.tree(this.dirname, function(filename) {
        return file.isMd(filename) || file.isDir(filename);
      });
      if (this.rootNode.notExists) {
        util.puts('Path "' + this.rootNode.name + '" not existed.');
      }
      return this.mdLength = this.getMdFiles().length;
    };

    TrashList.prototype.iterate = function(callback) {
      var iterate;
      iterate = function(node) {
        var child, _i, _len, _ref, _results;
        if (node.children) {
          _ref = node.children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            _results.push(iterate(child));
          }
          return _results;
        } else {
          return callback(node);
        }
      };
      return iterate(this.rootNode);
    };

    TrashList.prototype.getMdFiles = function() {
      var files;
      files = [];
      this.iterate(function(node) {
        return files.push(node);
      });
      return files;
    };

    TrashList.prototype.selectFile = function(num) {
      this.num = this._resolveNum(num);
      return this._rend();
    };

    TrashList.prototype.getSelectedFile = function() {
      var num;
      num = this._resolveNum(num);
      return this.getMdFiles()[num];
    };

    TrashList.prototype.recoveryFile = function(num) {
      var selectFile;
      selectFile = this.getSelectedFile(num);
      if (selectFile && !selectFile.children) {
        file.recovery(selectFile.name);
        this.msg = '\nFile "' + file.getFileName(selectFile.name) + '" recovered.';
        this._createRoot();
        return this._rend();
      } else {
        this.msg = 'Nothing selected.';
        return this._rend();
      }
    };

    TrashList.prototype._resolveNum = function(num) {
      if ((num != null)) {
        if (num < 0) {
          return num + this.mdLength;
        } else {
          return num % this.mdLength;
        }
      } else {
        return this.num;
      }
    };

    TrashList.prototype._rend = function() {
      charm.erase('screen');
      charm.cursor(false);
      charm.position(0, 0);
      this._rendTree();
      util.puts(this.shortcutTip);
      charm.cursor(true);
      return this._printStatus();
    };

    TrashList.prototype._rendTree = function() {
      var iterate, level, num,
        _this = this;
      util.puts(this.listTip);
      level = -1;
      num = -1;
      iterate = function(node) {
        var child, filename, i, indent, l, limit, symbol, _i, _len, _ref;
        level++;
        indent = '';
        i = 0;
        l = level * 4;
        limit = l - 3;
        while (i < l) {
          i++;
          if (i < limit) {
            symbol = ' ';
          }
          if (i === limit) {
            symbol = '|';
          }
          if (i > limit) {
            symbol = '-';
          }
          indent += symbol;
        }
        if (file.isMd(node.name)) {
          filename = file.pathToTitle(node.name);
          num++;
          if (num === _this.num) {
            filename = clc.underline(filename);
            indent = indent.replace(/-/g, '>');
          }
        } else {
          filename = file.getFileName(node.name);
        }
        util.puts(indent + ' ' + filename);
        if (node.children) {
          _ref = node.children;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            iterate(child);
          }
        }
        return level--;
      };
      return iterate(this.rootNode);
    };

    TrashList.prototype._bindEvent = function() {
      var newTitle, stdin,
        _this = this;
      stdin = process.stdin;
      stdin.setRawMode(true);
      stdin.resume();
      stdin.setEncoding('utf8');
      newTitle = '';
      return stdin.on('data', function(key) {
        if (key === '\u0003') {
          process.exit();
        }
        switch (key) {
          case 'q':
            return process.exit();
          case 'r':
            return _this.recoveryFile();
          case 'j':
            return _this.selectFile(_this.num + 1);
          case 'k':
            return _this.selectFile(_this.num - 1);
        }
      });
    };

    TrashList.prototype._printStatus = function() {
      if ((this.msg != null)) {
        return util.puts(this.msg);
      }
    };

    return TrashList;

  })();

  module.exports = function(args) {
    var arg;
    arg = parseArg(args);
    return new TrashList();
  };

}).call(this);
